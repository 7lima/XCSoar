/* Generated by Together */

#ifndef SAMPLEDTASKPOINT_H
#define SAMPLEDTASKPOINT_H

#include <vector>
#include "Util.h"
#include "Scoring/ObservationZone.hpp"
#include "SearchPoint.hpp"
#include "TaskPoint.hpp"

class SampledTaskPoint:
  public TaskPoint, 
  public ObservationZone
{
public:  
  SampledTaskPoint(const WAYPOINT & wp, bool b_scored):
    TaskPoint(wp),
    boundary_scored(b_scored)
  {
      clear_boundary_points();
      clear_sample_points();
  };

  const std::vector<SEARCH_POINT>& get_search_points(bool cheat=false);

  const std::vector<SEARCH_POINT>& get_boundary_points() const;

  virtual bool prune_boundary_points();

  virtual bool prune_sample_points();

  virtual void clear_boundary_points() {
    boundary_points.clear();
    search_max.Location = getLocation();
    search_min.Location = getLocation();
  }

  virtual void clear_sample_points() {
    sampled_points.clear();
  }

  void set_search_max(const SEARCH_POINT &i) {
    search_max = i;
  }

  void set_search_min(const SEARCH_POINT &i) {
    search_min = i;
  }

  const SEARCH_POINT& get_search_max() {
    return search_max;
  }

  const SEARCH_POINT& get_search_min() {
    return search_min;
  }

  virtual void default_boundary_points();

  GEOPOINT getMaxLocation() const {
    return search_max.Location;
  };
  GEOPOINT getMinLocation() const {
    return search_min.Location;
  };

  virtual bool update_sample(const AIRCRAFT_STATE&);

protected:
  bool boundary_scored;

private:
  std::vector<SEARCH_POINT> sampled_points;
  std::vector<SEARCH_POINT> boundary_points;
  SEARCH_POINT search_max;
  SEARCH_POINT search_min;
};
#endif //SAMPLEDOBSERVATIONZONE_H
