/* Generated by Together */

#include "OrderedTaskPoint.hpp"
#include "Math/Earth.hpp"
#include "TaskLeg.h"
#include <stdio.h>
#include <assert.h>
#include <math.h>
#include "GlideSolvers/GlideResult.hpp"
#include "GlideSolvers/GlidePolar.hpp"
#include "GlideSolvers/GlideState.hpp"

OrderedTaskPoint* 
OrderedTaskPoint::get_previous() const
{
  return leg_in->get_origin();
}

OrderedTaskPoint* 
OrderedTaskPoint::get_next() const
{
  return leg_out->get_destination();
}


// -------

GEOPOINT 
OrderedTaskPoint::get_reference_travelled() const
{
  if (has_entered()) {
    return getMaxLocation();
  } else {
    return getLocation();
  }
}

GEOPOINT 
OrderedTaskPoint::get_reference_scored() const
{
  return getLocation();
}

GEOPOINT 
OrderedTaskPoint::get_reference_nominal() const
{
  return getLocation();
}

GEOPOINT 
OrderedTaskPoint::get_reference_remaining() const
{
  if (has_entered()) {
    return getMinLocation();
  } else {
    return getLocation();
  }
}

// -------


TaskLeg* 
OrderedTaskPoint::get_leg_in() const
{
  return leg_in;
}

TaskLeg* 
OrderedTaskPoint::get_leg_out() const
{
  return leg_out;
}

void 
OrderedTaskPoint::set_leg_in(TaskLeg* the_leg)
{
  leg_in = the_leg;
}

void 
OrderedTaskPoint::set_leg_out(TaskLeg* the_leg) 
{
  leg_out = the_leg;
}

bool 
OrderedTaskPoint::scan_active(OrderedTaskPoint* atp) 
{
  // reset
  active_state = NOTFOUND_ACTIVE;

  if (atp == this) {
    active_state = CURRENT_ACTIVE;
  } else if (leg_in 
             && ((get_previous()->getActiveState() 
                  == CURRENT_ACTIVE) 
                 || (get_previous()->getActiveState() 
                     == AFTER_ACTIVE))) {
    active_state = AFTER_ACTIVE;
  } else {
    active_state = BEFORE_ACTIVE;
  }

  if (leg_out) { 
    // propagate to remainder of task
    return get_next()->scan_active(atp);
  } else if (active_state == BEFORE_ACTIVE) {
    return false;
  } else {
    return true;
  }
}

//////////


double 
OrderedTaskPoint::scan_distance_remaining(const GEOPOINT &ref) 
{
  // distance remaining from the given task point
  // (accumulates towards start)

  if (leg_in) {
    this_distance_remaining = leg_in->leg_distance_remaining(ref);
    bearing_remaining = leg_in->leg_bearing_remaining(ref);
  } else {
    this_distance_remaining = 0.0;
    bearing_remaining = ::Bearing(ref, getLocation()); // bearing to start
  }

  if (leg_out) {
    distance_remaining = get_next()->scan_distance_remaining(ref)
      +get_next()->this_distance_remaining;
  } else {
    // finish, reset
    distance_remaining = 0.0;
  }

  return distance_remaining;
}


////

double 
OrderedTaskPoint::scan_distance_max() 
{
  if (leg_out) {   
    double d = leg_out->leg_distance_max();
    return get_next()->scan_distance_max()+d;
  } else {
    return 0.0;
  }
}

double 
OrderedTaskPoint::scan_distance_min() 
{
  if (leg_out) {   
    double d = leg_out->leg_distance_min();
    return get_next()->scan_distance_min()+d;
  } else {
    return 0.0;
  }
}


double 
OrderedTaskPoint::scan_distance_nominal() 
{
  // distance from start to the task point
  // (accumulates towards finish)

  if (!leg_in) {
    // start, reset
    distance_nominal = 0.0;
  }
  if (leg_out) {
    double d = leg_out->leg_distance_nominal();
    get_next()->distance_nominal = d+distance_nominal;
    return get_next()->scan_distance_nominal();
  } else {
    // return at end
    return distance_nominal;
  }
}

double 
OrderedTaskPoint::scan_distance_planned() 
{
  // distance from start to the task point
  // (accumulates towards finish)
  if (leg_in) {
    bearing_planned = leg_in->leg_bearing_planned();
    this_distance_planned = leg_in->leg_distance_planned();
    distance_planned = this_distance_planned
      +get_previous()->distance_planned;
  } else {
    this_distance_planned = 0.0;
    bearing_planned = 0.0;
    distance_planned = 0;
  }
  if (leg_out) {
    return get_next()->scan_distance_planned();
  } else {
    return distance_planned;
  }
}


double 
OrderedTaskPoint::scan_distance_travelled(const GEOPOINT &ref) 
{
  if (leg_in) {
    bearing_travelled = leg_in->leg_bearing_travelled(ref);
    this_distance_travelled = leg_in->leg_distance_travelled(ref);
    distance_travelled = this_distance_travelled
      +get_previous()->distance_travelled;
  } else {
    distance_travelled = 0;
    this_distance_travelled = 0.0;
    if (leg_out) {
      bearing_travelled = leg_out->leg_bearing_travelled(ref);
    } else {
      bearing_travelled = 0.0;
    }
  }
  if (leg_out) {
    return get_next()->scan_distance_travelled(ref);
  } else {
    return distance_travelled;
  }
}


double 
OrderedTaskPoint::scan_distance_scored(const GEOPOINT &ref) 
{
  if (leg_in) {
    distance_scored = leg_in->leg_distance_scored(ref)
      +get_previous()->distance_scored;
  } else {
    distance_scored = 0;
  }
  if (leg_out) {
    return get_next()->scan_distance_scored(ref);
  } else {
    return distance_scored;
  }
}


bool 
OrderedTaskPoint::transition_enter(const AIRCRAFT_STATE & ref_now, 
                                   const AIRCRAFT_STATE & ref_last)
{
  bool entered = ObservationZone::transition_enter(ref_now, ref_last);
  if (entered) {
    state_entered = ref_now;
  }
  return entered;
}

bool 
OrderedTaskPoint::transition_exit(const AIRCRAFT_STATE & ref_now, 
                                  const AIRCRAFT_STATE & ref_last)
{
  bool exited = ObservationZone::transition_exit(ref_now, ref_last);
  if (exited) {
    state_exited = ref_last;
  }
  return exited;
}


void 
OrderedTaskPoint::print(std::ostream& f, const AIRCRAFT_STATE& state,
                        const int item) const
{
  if (item==0) {
    SampledTaskPoint::print(f,state);
    f << "# Entered " << state_entered.Time << "\n";
    f << "# Bearing travelled " << bearing_travelled << "\n";
    f << "# Distance travelled " << this_distance_travelled << "\n";
    f << "# Bearing remaining " << bearing_remaining << "\n";
    f << "# Distance remaining " << this_distance_remaining << "\n";
    f << "# Bearing planned " << bearing_planned << "\n";
    f << "# Distance planned " << this_distance_planned << "\n";
  }
}

const std::vector<SearchPoint>& 
OrderedTaskPoint::get_search_points()
{
  if (active_state== BEFORE_ACTIVE) {
    return SampledTaskPoint::get_search_points(true);
  } else if (active_state == CURRENT_ACTIVE) {
    return SampledTaskPoint::get_search_points(false);
  } else {
    return get_boundary_points();
  }
}


double 
OrderedTaskPoint::get_distance_remaining(const AIRCRAFT_STATE &) const
{
  return this_distance_remaining;
}

double 
OrderedTaskPoint::get_bearing_remaining(const AIRCRAFT_STATE &) const
{
  return bearing_remaining;
}


GLIDE_RESULT 
OrderedTaskPoint::glide_solution_travelled(const AIRCRAFT_STATE &ac, 
                                           const GlidePolar &polar,
                                           const double minH) const
{
  GLIDE_STATE gs(get_distance_travelled(),
                 get_bearing_travelled(),
                 std::max(minH,getElevation()),
                 ac);
  return polar.solve(gs);
}

GLIDE_RESULT 
OrderedTaskPoint::glide_solution_planned(const AIRCRAFT_STATE &ac, 
                                         const GlidePolar &polar,
                                         const double minH) const
{
  GLIDE_STATE gs(get_distance_planned(),
                 get_bearing_planned(),
                 std::max(minH,getElevation()),
                 ac);
  return polar.solve(gs);
}


double 
OrderedTaskPoint::double_leg_distance(const GEOPOINT &ref) const
{
  assert(leg_in);
  assert(leg_out);
/* slow
  return 
    ::Distance(leg_in->get_origin()->get_reference_remaining(), 
               ref)+
    ::Distance(ref,
               leg_out->get_destination()->get_reference_remaining());
*/
  GEOPOINT p1 = get_previous()->get_reference_remaining();
  GEOPOINT p2 = get_next()->get_reference_remaining();
  return ::DoubleDistance(p1, ref, p2);
}
