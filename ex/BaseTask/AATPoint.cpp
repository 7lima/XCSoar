/* Generated by Together */

#include "AATPoint.hpp"
#include "Util.h"
#include "Math/Earth.hpp"

GEOPOINT AATPoint::get_reference_scored() const
{
  if (getActiveState() == BEFORE_ACTIVE) {
    return getMaxLocation();
  } else {
    return getMinLocation();
  }
}

GEOPOINT AATPoint::get_reference_travelled() const
{
  if (state_entered.Time>=0) {
    return getMaxLocation();
  } else {
    return getMinLocation();
  }
}

GEOPOINT AATPoint::get_reference_remaining() const
{
  if (getActiveState() == BEFORE_ACTIVE) {
    return getMaxLocation();
  } else {
    return TargetLocation;
  }
}

double 
AATPoint::getElevation() const
{
  // TODO: look up elevation of target and use that instead
  return Elevation; // + SAFETYTERRAIN
}

bool 
AATPoint::update_sample(const AIRCRAFT_STATE& state) 
{
  bool retval = OrderedTaskPoint::update_sample(state);
  if (active_state == CURRENT_ACTIVE) {
    retval |= check_target(state);
  }

  update_isoline();

  return retval;
}

// target handling

bool
AATPoint::check_target(const AIRCRAFT_STATE& state) 
{
  bool moved = false;
  if (isInSector(state)) {
    moved = check_target_inside(state);
  } else {
    moved = check_target_outside(state);
  }
  return moved;
}

bool
AATPoint::check_target_inside(const AIRCRAFT_STATE& state) 
{
  // target must be moved if d(p_last,t)+d(t,p_next) 
  //    < d(p_last,state)+d(state,p_next)
  if (double_leg_distance(TargetLocation) 
      < double_leg_distance(state.Location)) 
  {
    const double d_in_front = 0.01;
    const double d_to_max = ::Distance(state.Location, 
                                       getMaxLocation());

    if (d_to_max<d_in_front) {
      // no improvement available
      return false;
    } else {
      const double p = d_in_front/d_to_max;
      TargetLocation = ::InterpolateLocation(state.Location, 
                                             getMaxLocation(), p); 
      return true;
    }
  } else {
    return false;
  }
}

bool
AATPoint::check_target_outside(const AIRCRAFT_STATE& state) 
{

  return false;
}


void 
AATPoint::set_range(const double p)
{
  TargetLocation = ::InterpolateLocation(getMinLocation(), 
                                         getMaxLocation(), p);
}


void 
AATPoint::update_projection()
{
  OrderedTaskPoint::update_projection();  

// TODO: update ellipse if we have one saved
}

////////////////////////////////////////////

#include "GlideSolvers/ZeroFinder.hpp"

class GeoEllipse {
public:
  GeoEllipse(const GEOPOINT &f1, const GEOPOINT &f2,
             const GEOPOINT &p,
             const TaskProjection &_task_projection): 
    task_projection(_task_projection)
    {
      ell = FlatEllipse(task_projection.fproject(f1),
                        task_projection.fproject(f2),
                        task_projection.fproject(p));
    }
  double t_initial() {
    return ell.theta_initial/360.0;
  }
  GEOPOINT parametric(double t) {
    FlatPoint p = ell.parametric(t);
    return task_projection.funproject(p);
  };
private:
  TaskProjection task_projection;
  FlatEllipse ell;
};


class IsolineCrossingFinder:
  public ZeroFinder
{
public:
  IsolineCrossingFinder(const AATPoint& _aap,
                        GeoEllipse &_ell,
                        const double xmin, 
                        const double xmax):
    aap(_aap),
    ell(_ell),
    ZeroFinder(xmin, xmax, 0.0001) {};

  double f(const double t) {
    GEOPOINT a = ell.parametric(t);
    AIRCRAFT_STATE s;
    s.Location = a;

    // note: use of isInSector is slow!
    if (aap.isInSector(s)) {
      return 1.0;
    } else {
      return -1.0;
    }
  }
private:
  GeoEllipse &ell;
  const AATPoint &aap;
};


void 
AATPoint::update_isoline()
{
/*
  GeoEllipse ell(get_previous()->getLocation(),
                 get_next()->getLocation(),
                 TargetLocation,
                 task_projection);

  IsolineCrossingFinder icf_up(*this, ell, 0.0, 0.5);
  IsolineCrossingFinder icf_down(*this, ell, -0.5, 0.0);

  double t_z_up = icf_up.find_zero(0.0);
  double t_z_down = icf_down.find_zero(0.0);
*/
}




void AATPoint::print(std::ostream& f, const int item) const
{
  switch(item) {
  case 0:
    OrderedTaskPoint::print(f);
    f << "#   Target\n";
    f << "#     " << TargetLocation.Longitude << "," 
      << TargetLocation.Latitude << "\n";
    break;

  case 1:

    GeoEllipse ell(get_previous()->getLocation(),
                   get_next()->getLocation(),
                   TargetLocation,
                   task_projection);

    IsolineCrossingFinder icf_up(*this, ell, 0.0, 0.5);
    IsolineCrossingFinder icf_down(*this, ell, -0.5, 0.0);

    const double t_z_up = icf_up.find_zero(0.0);
    const double t_z_down = icf_down.find_zero(0.0);
    const double dt = (t_z_up-t_z_down)/20.0;
    
    if (t_z_up>t_z_down) {
      for (double t = t_z_down; t<= t_z_up; t+= dt) {
        GEOPOINT ga = ell.parametric(t);
        f << ga.Longitude << " " << ga.Latitude << "\n";
      }
      f << "\n";
    }
    break;
  };
}

