/* Generated by Together */

#include "AATPoint.hpp"
#include "Util.h"
#include "Math/Earth.hpp"

GEOPOINT AATPoint::get_reference_scored() const
{
  if (getActiveState() == BEFORE_ACTIVE) {
    return getMaxLocation();
  } else {
    return getMinLocation();
  }
}

GEOPOINT AATPoint::get_reference_travelled() const
{
  if (state_entered.Time>=0) {
    return getMaxLocation();
  } else {
    return getMinLocation();
  }
}

GEOPOINT AATPoint::get_reference_remaining() const
{
  if (getActiveState() == BEFORE_ACTIVE) {
    return getMaxLocation();
  } else {
    return TargetLocation;
  }
}

double 
AATPoint::getElevation() const
{
  // TODO: look up elevation of target and use that instead
  return Elevation; // + SAFETYTERRAIN
}

bool 
AATPoint::update_sample(const AIRCRAFT_STATE& state) 
{
  bool retval = OrderedTaskPoint::update_sample(state);
  if (active_state == CURRENT_ACTIVE) {
    retval |= check_target(state);
  }
  return retval;
}

// target handling

bool
AATPoint::check_target(const AIRCRAFT_STATE& state) 
{
  bool moved = false;
  if (isInSector(state)) {
    moved = check_target_inside(state);
  } else {
    moved = check_target_outside(state);
  }
  return moved;
}

bool
AATPoint::check_target_inside(const AIRCRAFT_STATE& state) 
{
  // target must be moved if d(p_last,t)+d(t,p_next) < d(p_last,state)+d(state,p_next)
  if (double_leg_distance(TargetLocation) < double_leg_distance(state.Location)) 
  {
    const double d_in_front = 0.01;
    const double d_to_max = ::Distance(state.Location, getMaxLocation());

    if (d_to_max<d_in_front) {
      // no improvement available
      return false;
    } else {
      const double p = d_in_front/d_to_max;
      TargetLocation = ::InterpolateLocation(state.Location, getMaxLocation(), p); 
      return true;
    }
  } else {
    return false;
  }
}

bool
AATPoint::check_target_outside(const AIRCRAFT_STATE& state) 
{

  return false;
}

void AATPoint::print(std::ostream& f) const
{
  OrderedTaskPoint::print(f);
  f << "#   Target\n";
  f << "#     " << TargetLocation.Longitude << "," 
    << TargetLocation.Latitude << "\n";
}


void 
AATPoint::set_range(const double p)
{
  TargetLocation = ::InterpolateLocation(getMinLocation(), getMaxLocation(), p);
}
