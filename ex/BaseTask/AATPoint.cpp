/* Generated by Together */

#include "AATPoint.hpp"
#include "Util.h"
#include "Math/Earth.hpp"

GEOPOINT AATPoint::get_reference_scored() const
{
  if (getActiveState() == BEFORE_ACTIVE) {
    return getMaxLocation();
  } else {
    return getMinLocation();
  }
}

GEOPOINT AATPoint::get_reference_travelled() const
{
  if (state_entered.Time>=0) {
    return getMaxLocation();
  } else {
    return getMinLocation();
  }
}

GEOPOINT AATPoint::get_reference_remaining() const
{
  if (getActiveState() == BEFORE_ACTIVE) {
    return getMaxLocation();
  } else {
    return TargetLocation;
  }
}

double 
AATPoint::getElevation() const
{
  // TODO: look up elevation of target and use that instead
  return Elevation; // + SAFETYTERRAIN
}

bool 
AATPoint::update_sample(const AIRCRAFT_STATE& state) 
{
  bool retval = OrderedTaskPoint::update_sample(state);
  if (active_state == CURRENT_ACTIVE) {
    retval |= check_target(state);
  }

  update_isoline();

  return retval;
}

// target handling

bool
AATPoint::check_target(const AIRCRAFT_STATE& state) 
{
  bool moved = false;
  if (isInSector(state)) {
    moved = check_target_inside(state);
  } else {
    moved = check_target_outside(state);
  }
  return moved;
}

bool
AATPoint::check_target_inside(const AIRCRAFT_STATE& state) 
{
  // target must be moved if d(p_last,t)+d(t,p_next) 
  //    < d(p_last,state)+d(state,p_next)
  if (double_leg_distance(TargetLocation) 
      < double_leg_distance(state.Location)) 
  {
    const double d_in_front = 0.01;
    const double d_to_max = ::Distance(state.Location, 
                                       getMaxLocation());

    if (d_to_max<d_in_front) {
      // no improvement available
      return false;
    } else {
      const double p = d_in_front/d_to_max;
      TargetLocation = ::InterpolateLocation(state.Location, 
                                             getMaxLocation(), p); 
      return true;
    }
  } else {
    return false;
  }
}

bool
AATPoint::check_target_outside(const AIRCRAFT_STATE& state) 
{

  return false;
}

void AATPoint::print(std::ostream& f, const int item) const
{
  switch(item) {
  case 0:
    OrderedTaskPoint::print(f);
    f << "#   Target\n";
    f << "#     " << TargetLocation.Longitude << "," 
      << TargetLocation.Latitude << "\n";
    break;

  case 1:
    FlatPoint f1 = fproject(get_previous()->getLocation());
    FlatPoint f2 = fproject(get_next()->getLocation());
    FlatPoint p = fproject(TargetLocation);
    
    FlatEllipse e(f1,f2,p);

    for (double t=-0.05; t<=0.05; t+= 0.001) {
      FlatPoint a = e.parametric(t);
      GEOPOINT ga = funproject(a);
      AIRCRAFT_STATE s;
      s.Location = ga;
      if (isInSector(s)) {
        f << ga.Longitude << " " << ga.Latitude << "\n";
      }
    }
    f << "\n";
    break;
  };
}


void 
AATPoint::set_range(const double p)
{
  TargetLocation = ::InterpolateLocation(getMinLocation(), 
                                         getMaxLocation(), p);
}


void 
AATPoint::update_projection()
{
  OrderedTaskPoint::update_projection();  
}


void 
AATPoint::update_isoline()
{
  FlatPoint f1 = fproject(get_previous()->getLocation());
  FlatPoint f2 = fproject(get_next()->getLocation());
  FlatPoint p = fproject(TargetLocation);

  FlatEllipse e(f1,f2,p);

  for (double t=0; t<=1.0; t+= 0.01) {
    FlatPoint a = e.parametric(t);
    GEOPOINT ga = funproject(a);
    AIRCRAFT_STATE s;
    s.Location = ga;
    if (isInSector(s)) {
//      printf("%g %g\n",ga.Longitude,ga.Latitude);
    }
  }
/*
  
  we have known point inside, corresponding to t=0, theta_initial
  t_initial = theta_initial/360.0

  use zerofinder to scan forward in range from t_initial to 1.0 
  for zero crossing of sgn(isInSector(xx))

  use zerofinder to scan backwards in range from t_initial to 0.0 

  now we have absolute limits of ellipse
*/

}
