/* Generated by Together */

#include "TaskLeg.h"
#include "Math/Earth.hpp"
#include "OrderedTaskPoint.hpp"
#include <assert.h>
#include <algorithm>

double TaskLeg::leg_distance_scored(const OrderedTaskPoint *tp_origin,
                                    const OrderedTaskPoint *tp_destination,
                                    const GEOPOINT &ref) const
{
  switch (tp_destination->getActiveState()) {
  case OrderedTaskPoint::BEFORE_ACTIVE:
    // this leg totally included
    return 
      std::max(0.0,
               ::Distance(tp_origin->get_reference_scored(), 
                          tp_destination->get_reference_scored())
               -tp_origin->score_adjustment()-tp_destination->score_adjustment());
    break;
  case OrderedTaskPoint::AFTER_ACTIVE:
    // this leg not included
    return 0.0;
  case OrderedTaskPoint::CURRENT_ACTIVE:
    // this leg partially included
    return 
      std::max(0.0,
               ::ProjectedDistance(tp_origin->get_reference_scored(), 
                                   tp_destination->get_reference_scored(),
                                   ref)
               -tp_origin->score_adjustment()-tp_destination->score_adjustment());
    break;
  default:
    assert(1); // error!
    break;
  };
  assert(1); // error!
  return 0.0;
}


double TaskLeg::leg_distance_remaining(const OrderedTaskPoint *tp_origin,
                                       const OrderedTaskPoint *tp_destination,
                                       const GEOPOINT &ref) const
{
  switch (tp_destination->getActiveState()) {
  case OrderedTaskPoint::AFTER_ACTIVE:
    // this leg totally included
    return 
      ::Distance(tp_origin->get_reference_remaining(), 
                 tp_destination->get_reference_remaining());
    break;
  case OrderedTaskPoint::BEFORE_ACTIVE:
    // this leg not included
    return 0.0;
  case OrderedTaskPoint::CURRENT_ACTIVE:
    // this leg partially included
    return 
      ::Distance(ref, 
                 tp_destination->get_reference_remaining());
    break;
  default:
    assert(1); // error!
    break;
  };
  assert(1); // error!
  return 0.0;
}


double TaskLeg::leg_distance_travelled(const OrderedTaskPoint *tp_origin,
                                       const OrderedTaskPoint *tp_destination,
                                       const GEOPOINT &ref) const
{
  switch (tp_destination->getActiveState()) {
  case OrderedTaskPoint::BEFORE_ACTIVE:
    // this leg totally included
    return 
      ::Distance(tp_origin->get_reference_travelled(), 
                 tp_destination->get_reference_travelled());
    break;
  case OrderedTaskPoint::AFTER_ACTIVE:
    // this leg not included
    return 0.0;
  case OrderedTaskPoint::CURRENT_ACTIVE:
    // this leg partially included
    if (tp_destination->has_entered()) {
      return ::Distance(tp_origin->get_reference_travelled(), 
                        tp_destination->get_reference_travelled())
        +::Distance(tp_destination->get_reference_travelled(), 
                    ref);
    } else {
      return 
        ::Distance(tp_origin->get_reference_travelled(), 
                   ref);
    }
    break;
  default:
    assert(1); // error!
    break;
  };
  assert(1); // error!
  return 0.0;
}

double TaskLeg::leg_distance_nominal(const OrderedTaskPoint *tp_origin,
                                     const OrderedTaskPoint *tp_destination) const
{
  return 
    ::Distance(tp_origin->get_reference_nominal(), 
               tp_destination->get_reference_nominal());
}


double TaskLeg::leg_distance_planned(const OrderedTaskPoint *tp_origin,
                                     const OrderedTaskPoint *tp_destination) const
{
  return
    ::Distance(tp_origin->get_reference_travelled(), 
               tp_destination->get_reference_travelled());
}

double TaskLeg::leg_bearing_planned(const OrderedTaskPoint *tp_origin,
                                    const OrderedTaskPoint *tp_destination) const
{
  return
    ::Bearing(tp_origin->get_reference_travelled(), 
              tp_destination->get_reference_travelled());
}


double TaskLeg::leg_distance_max(const OrderedTaskPoint *tp_origin,
                                 const OrderedTaskPoint *tp_destination) const
{
  return 
    ::Distance(tp_origin->getMaxLocation(), 
               tp_destination->getMaxLocation());
}

double TaskLeg::leg_distance_min(const OrderedTaskPoint *tp_origin,
                                 const OrderedTaskPoint *tp_destination) const
{
  return 
    ::Distance(tp_origin->getMinLocation(), 
               tp_destination->getMinLocation());
}


double TaskLeg::leg_bearing_remaining(const OrderedTaskPoint *tp_origin,
                                      const OrderedTaskPoint *tp_destination,
                                      const GEOPOINT &ref) const
{
  switch (tp_destination->getActiveState()) {
  case OrderedTaskPoint::AFTER_ACTIVE:
    // this leg totally included
    return 
      ::Bearing(tp_origin->get_reference_remaining(), 
                tp_destination->get_reference_remaining());
    break;
  case OrderedTaskPoint::BEFORE_ACTIVE:
    // this leg not included
    return 0.0;
  case OrderedTaskPoint::CURRENT_ACTIVE:
    // this leg partially included
    return 
      ::Bearing(ref, 
                tp_destination->get_reference_remaining());
    break;
  default:
    assert(1); // error!
    break;
  };
  assert(1); // error!
  return 0.0;
}


double TaskLeg::leg_bearing_travelled(const OrderedTaskPoint *tp_origin,
                                      const OrderedTaskPoint *tp_destination,
                                      const GEOPOINT &ref) const
{
  switch (tp_destination->getActiveState()) {
  case OrderedTaskPoint::BEFORE_ACTIVE:
    // this leg totally included
    return 
      ::Bearing(tp_origin->get_reference_travelled(), 
                tp_destination->get_reference_travelled());
    break;
  case OrderedTaskPoint::AFTER_ACTIVE:
    // this leg not included
    return 0.0;
  case OrderedTaskPoint::CURRENT_ACTIVE:
    // this leg partially included
    return 
      ::Bearing(tp_origin->get_reference_travelled(), 
                ref);
    break;
  default:
    assert(1); // error!
    break;
  };
  assert(1); // error!
  return 0.0;
}
