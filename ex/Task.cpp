/* Generated by Together */
#include <fstream>
#include <iostream>

#include "Task.h"
#include "TaskDijkstra.hpp"
#include <stdio.h>
#include <math.h>

#include "TaskPoints/FAISectorStartPoint.hpp"
#include "TaskPoints/FAISectorASTPoint.hpp"
#include "TaskPoints/FAICylinderASTPoint.hpp"
#include "TaskPoints/FAISectorFinishPoint.hpp"

#include <assert.h>


Task::Task():
  activeTaskPoint(0)
{
  WAYPOINT wp[6];
  wp[0].Location.Longitude=0;
  wp[0].Location.Latitude=0;
  wp[1].Location.Longitude=0;
  wp[1].Location.Latitude=10;
  wp[2].Location.Longitude=10;
  wp[2].Location.Latitude=10;
  wp[3].Location.Longitude=7;
  wp[3].Location.Latitude=5;
  wp[4].Location.Longitude=10;
  wp[4].Location.Latitude=0;

  ts = new FAISectorStartPoint(wp[0]);
  tps.push_back(ts);
  tps.push_back(new FAISectorASTPoint(wp[1]));
  tps.push_back(new FAISectorASTPoint(wp[2]));
  tps.push_back(new FAICylinderASTPoint(wp[3]));
  tps.push_back(new FAISectorFinishPoint(wp[4]));

  for (int i=0; i<tps.size()-1; i++) {
    legs.push_back(new TaskLeg(*tps[i],*tps[i+1]));
  }

  update_geometry();
}

void
Task::update_geometry() {
  for (int i=0; i<tps.size(); i++) {
    tps[i]->update_geometry();
    tps[i]->clear_boundary_points();
    tps[i]->default_boundary_points();
    tps[i]->prune_boundary_points();
  }
}

Task::~Task()
{
// TODO: delete legs and turnpoints
}

void Task::setActiveTaskPoint(unsigned t)
{
  activeTaskPoint = t;
}

void Task::scan_distance(const GEOPOINT &location, bool full) 
{ 
  TaskDijkstra dijkstra(this);
  ScanTaskPoint start(0,0);

  double d;

  ts->scan_active(getActiveTaskPoint());

  if (full) {
    distance_nominal = ts->scan_distance_nominal();
    distance_max = dijkstra.distance_opt_achieved(location, false);
  }

  distance_min = dijkstra.distance_opt_achieved(location, true);
  distance_remaining = ts->scan_distance_remaining(location);
  distance_travelled = ts->scan_distance_travelled(location);
  distance_scored = ts->scan_distance_scored(location);
}


OrderedTaskPoint* Task::getActiveTaskPoint()
{
  return tps[activeTaskPoint];
}
 
unsigned Task::getActiveTaskPointIndex() 
{
  return activeTaskPoint;
}

void 
Task::insert(OrderedTaskPoint* new_tp, unsigned position)
{
  // remove legs first
  assert(position>0);

  if (activeTaskPoint>=position) {
    activeTaskPoint++;
  }

  delete legs[position-1];
  legs.erase(legs.begin()+position-1); // 0,1,2 -> 0,2

  tps.insert(tps.begin()+position, new_tp); // 0,1,2 -> 0,1,N,2

  legs.insert(legs.begin()+position-1,
              new TaskLeg(*tps[position-1],*tps[position])); // 0,1N,2

  legs.insert(legs.begin()+position,
              new TaskLeg(*tps[position],*tps[position+1])); // 0,1N,N2,2
  
  update_geometry();
}

void
Task::remove(unsigned position)
{
  assert(position>0);
  assert(position<tps.size()-1);

  if (activeTaskPoint>position) {
    activeTaskPoint--;
  }

  delete legs[position-1]; 
  delete legs[position];   // 01,12,23,34 -> 01,34 
  legs.erase(legs.begin()+position-1); // 01,12,23,34 -> 01,23,34 
  legs.erase(legs.begin()+position-1); // 01,12,23,34 -> 01,34 

  delete tps[position];
  tps.erase(tps.begin()+position); // 0,1,2,3 -> 0,1,3

  legs.insert(legs.begin()+position-1,
              new TaskLeg(*tps[position-1],*tps[position])); // 01,13,34

  update_geometry();
}

int m_max(int a, int b) {
  if (a>b) {
    return a;
  } else {
    return b;
  }
}

int m_min(int a, int b) {
  if (a<b) {
    return a;
  } else {
    return b;
  }
}

bool Task::update_sample(const GEOPOINT& location, const GEOPOINT& last_location)
{
  ts->scan_active(getActiveTaskPoint());

  int n_task = tps.size();
  int t_min = m_max(0,activeTaskPoint-1);
  int t_max = m_min(n_task-1, activeTaskPoint+1);
  bool full_update = false;

  for (int i=t_min; i<=t_max; i++) {
    if (tps[i]->transition_exit(location, last_location)) {
      if (i<n_task-1) {
        printf("transition to sector %d\n", i+1);
        setActiveTaskPoint(i+1);
        ts->scan_active(getActiveTaskPoint());
        // auto advance on exit for testing
      }
    }
    if (tps[i]->update_sample(location)) {
      full_update = true;
    }
  }

  scan_distance(location, full_update);
  return true;
}

///////////////////////////////////////////////////////////////////

void print_tp(OrderedTaskPoint *tp, std::ofstream& f) {
  unsigned n= tp->get_boundary_points().size();
  for (unsigned i=0; i<n; i++) {
    GEOPOINT loc = tp->get_boundary_points()[i].Location;
    f << loc.Longitude << " " << loc.Latitude << "\n";
  }
  f << "\n";
}

extern int count_distance;

void Task::report(const GEOPOINT &location) 
{
/*
  d = dijkstra.distance_opt(start,true);
  printf("# absolute min dist %g\n",d);

  d = dijkstra.distance_opt(start,false);
  printf("# absolute max dist %g\n",d);
*/
  std::ofstream f1("res-task.txt");
  std::ofstream f2("res-max.txt");
  std::ofstream f3("res-min.txt");
  static std::ofstream f4("res-sample.txt");

  f1 << "#### Distances\n";
  f1 << "# dist nominal " << distance_nominal << "\n";
  f1 << "# min dist after achieving max " << distance_min << "\n";
  f1 << "# max dist after achieving max " << distance_max << "\n";
  f1 << "# dist remaining " << distance_remaining << "\n";
  f1 << "# dist travelled " << distance_travelled << "\n";
  f1 << "# dist scored " << distance_scored << "\n";

  f1 << "#### Task points\n";
  for (int i=0; i<tps.size(); i++) {
    print_tp(tps[i], f1);
  }

  f4 <<  location.Longitude << " " 
     <<  location.Latitude << "\n";

  f2 << "#### Max task\n";
  for (int i=0; i<tps.size(); i++) {
    OrderedTaskPoint *tp = tps[i];
    f2 <<  tp->get_search_max().Location.Longitude << " " 
       <<  tp->get_search_max().Location.Latitude << "\n";
  }

  f3 << "#### Min task\n";
  for (int i=0; i<tps.size(); i++) {
    OrderedTaskPoint *tp = tps[i];
    f3 <<  tp->get_search_min().Location.Longitude << " " 
       <<  tp->get_search_min().Location.Latitude << "\n";
  }

//  printf("distance tests %d\n", count_distance);
//  count_distance = 0;
}

