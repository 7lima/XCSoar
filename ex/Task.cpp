/* Generated by Together */

#include "Task.h"
#include "TaskDijkstra.hpp"
#include <stdio.h>
#include <math.h>

#include "TaskPoints/FAISectorStartPoint.hpp"
#include "TaskPoints/FAISectorASTPoint.hpp"
#include "TaskPoints/FAISectorFinishPoint.hpp"

#include <assert.h>


void print_tp(OrderedTaskPoint *tp) {
  unsigned n= tp->get_search_points().size();
  for (unsigned i=0; i<n; i++) {
    GEOPOINT loc = tp->get_search_points()[i].Location;
    printf("%g %g 1\n", loc.Longitude, loc.Latitude);
  }
  GEOPOINT loc = tp->get_search_points()[0].Location;
  printf("%g %g 1\n", loc.Longitude, loc.Latitude);
  printf("\n");
}

Task::Task():
  activeTaskPoint(0)
{
  WAYPOINT wp[6];
  wp[0].Location.Longitude=0;
  wp[0].Location.Latitude=0;
  wp[1].Location.Longitude=0;
  wp[1].Location.Latitude=10;
  wp[2].Location.Longitude=10;
  wp[2].Location.Latitude=10;
  wp[3].Location.Longitude=10;
  wp[3].Location.Latitude=0;
  wp[4].Location.Longitude=20;
  wp[4].Location.Latitude=0;

  ts = new FAISectorStartPoint(wp[0]);
  tps.push_back(ts);
  tps.push_back(new FAISectorASTPoint(wp[1]));
  tps.push_back(new FAISectorASTPoint(wp[2]));
  tps.push_back(new FAISectorASTPoint(wp[3]));
  tps.push_back(new FAISectorFinishPoint(wp[4]));

  for (int i=0; i<tps.size()-1; i++) {
    legs.push_back(new TaskLeg(*tps[i],*tps[i+1]));
  }

  update_geometry();
}

void
Task::update_geometry() {
  for (int i=0; i<tps.size(); i++) {
    tps[i]->update_geometry();
    tps[i]->clear_search_points();
    tps[i]->default_search_points();
    tps[i]->prune_search_points();
  }
}

Task::~Task()
{
// TODO: delete legs and turnpoints
}

void Task::setActiveTaskPoint(unsigned t)
{
  activeTaskPoint = t;
}

void Task::scan_distance(const GEOPOINT &location) 
{ 
  TaskDijkstra dijkstra(this);
  ScanTaskPoint start(0,0);

  double d;

  ts->scan_active(getActiveTaskPoint());

  d= ts->scan_distance_nominal();
  printf("# dist nominal %g\n", d);

  d = dijkstra.distance_opt_achieved(location, true);  
  printf("# min dist after achieving max %g\n",d);

  d = dijkstra.distance_opt_achieved(location, false);
  printf("# max dist after achieving max %g\n",d);

  d = ts->scan_distance_remaining(location);
  printf("# dist remaining %g\n", d);

  d = ts->scan_distance_travelled(location);
  printf("# dist travelled %g\n", d);

  d = ts->scan_distance_scored(location);
  printf("# dist scored %g\n", d);

  d = dijkstra.distance_opt(start,true);
  printf("# absolute min dist %g\n",d);

  d = dijkstra.distance_opt(start,false);
  printf("# absolute max dist %g\n",d);

  for (int i=0; i<tps.size(); i++) {
    print_tp(tps[i]);
  }

  for (int i=0; i<tps.size(); i++) {
    OrderedTaskPoint *tp = tps[i];
    printf("%g %g 2\n", tp->get_search_max().Location.Longitude,
           tp->get_search_max().Location.Latitude);
  }
  printf("\n");

  for (int i=0; i<tps.size(); i++) {
    OrderedTaskPoint *tp = tps[i];
    printf("%g %g 3\n", tp->get_search_min().Location.Longitude,
           tp->get_search_min().Location.Latitude);
  }

  printf("\n");
}


OrderedTaskPoint* Task::getActiveTaskPoint()
{
  return tps[activeTaskPoint];
}
 
unsigned Task::getActiveTaskPointIndex() 
{
  return activeTaskPoint;
}

void 
Task::insert(OrderedTaskPoint* new_tp, unsigned position)
{
  // remove legs first
  assert(position>0);

  if (activeTaskPoint>=position) {
    activeTaskPoint++;
  }

  delete legs[position-1];
  legs.erase(legs.begin()+position-1); // 0,1,2 -> 0,2

  tps.insert(tps.begin()+position, new_tp); // 0,1,2 -> 0,1,N,2

  legs.insert(legs.begin()+position-1,
              new TaskLeg(*tps[position-1],*tps[position])); // 0,1N,2

  legs.insert(legs.begin()+position,
              new TaskLeg(*tps[position],*tps[position+1])); // 0,1N,N2,2
  
  update_geometry();
}

void
Task::remove(unsigned position)
{
  assert(position>0);
  assert(position<tps.size()-1);

  if (activeTaskPoint>position) {
    activeTaskPoint--;
  }

  delete legs[position-1]; 
  delete legs[position];   // 01,12,23,34 -> 01,34 
  legs.erase(legs.begin()+position-1); // 01,12,23,34 -> 01,23,34 
  legs.erase(legs.begin()+position-1); // 01,12,23,34 -> 01,34 

  delete tps[position];
  tps.erase(tps.begin()+position); // 0,1,2,3 -> 0,1,3

  legs.insert(legs.begin()+position-1,
              new TaskLeg(*tps[position-1],*tps[position])); // 01,13,34

  update_geometry();
}

#define max(a,b) (a>b? a:b)
#define min(a,b) (a<b? a:b)

bool Task::update_sample(const GEOPOINT& location)
{
  ts->scan_active(getActiveTaskPoint());

  int n_task = tps.size();
  int t_min = max(0,activeTaskPoint-1);
  int t_max = min(n_task-1, activeTaskPoint);

  for (int i=t_min; i<=t_max; i++) {
    if (tps[i]->update_sample(location)) {
    }
  }

  scan_distance(location);
  return true;
}

  
