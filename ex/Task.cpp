/* Generated by Together */

#include "Task.h"
#include "TaskDijkstra.hpp"
#include <stdio.h>

#include "TaskPoints/FAISectorStartPoint.hpp"
#include "TaskPoints/FAISectorASTPoint.hpp"
#include "TaskPoints/FAISectorFinishPoint.hpp"

#include <assert.h>

Task::Task():
  activeTaskPoint(0)
{
  WAYPOINT wp[6];
  wp[0].Location.Longitude=0;
  wp[0].Location.Latitude=0;
  wp[1].Location.Longitude=0;
  wp[1].Location.Latitude=10;
  wp[2].Location.Longitude=10;
  wp[2].Location.Latitude=10;
  wp[3].Location.Longitude=10;
  wp[3].Location.Latitude=0;
  wp[4].Location.Longitude=20;
  wp[4].Location.Latitude=0;

  ts = new FAISectorStartPoint(wp[0]);
  tps.push_back(ts);
  tps.push_back(new FAISectorASTPoint(wp[1]));
  tps.push_back(new FAISectorASTPoint(wp[2]));
  tps.push_back(new FAISectorASTPoint(wp[3]));
  tps.push_back(new FAISectorFinishPoint(wp[4]));

  for (int i=0; i<tps.size()-1; i++) {
    legs.push_back(new TaskLeg(*tps[i],*tps[i+1]));
  }

  update_geometry();
}

void
Task::update_geometry() {
  for (int i=0; i<tps.size(); i++) {
    tps[i]->update_geometry();
    tps[i]->clear_search_points();
    tps[i]->default_search_points();
  }
}

Task::~Task()
{
// TODO: delete legs and turnpoints
}

void Task::setActiveTaskPoint(unsigned t)
{
  activeTaskPoint = t;
}

void Task::scan_distance(const GEOPOINT &location) 
{ 
  TaskDijkstra dijkstra(this);
  ScanTaskPoint start(0,0);

  double d;

  ts->scan_active(getActiveTaskPoint());

  d= ts->scan_distance_nominal();
  printf("# dist nominal %g\n", d);

  d = dijkstra.distance_opt_achieved(location, true);  
  printf("# min dist after achieving max %g\n",d);

  d = dijkstra.distance_opt_achieved(location, false);
  printf("# max dist after achieving max %g\n",d);

  d = ts->scan_distance_remaining(location);
  printf("# dist remaining %g\n", d);

  d = ts->scan_distance_travelled(location);
  printf("# dist travelled %g\n", d);

  d = ts->scan_distance_scored(location);
  printf("# dist scored %g\n", d);

  d = dijkstra.distance_opt(start,true);
  printf("# absolute min dist %g\n",d);

  d = dijkstra.distance_opt(start,false);
  printf("# absolute max dist %g\n",d);

  printf("\n");
}


OrderedTaskPoint* Task::getActiveTaskPoint()
{
  return tps[activeTaskPoint];
}
 
unsigned Task::getActiveTaskPointIndex() 
{
  return activeTaskPoint;
}

void 
Task::insert(OrderedTaskPoint* new_tp, unsigned position)
{
  // remove legs first
  assert(position>0);

  if (activeTaskPoint>=position) {
    activeTaskPoint++;
  }

  delete legs[position-1];
  legs.erase(legs.begin()+position-1); // 0,1,2 -> 0,2

  tps.insert(tps.begin()+position, new_tp); // 0,1,2 -> 0,1,N,2

  legs.insert(legs.begin()+position-1,
              new TaskLeg(*tps[position-1],*tps[position])); // 0,1N,2

  legs.insert(legs.begin()+position,
              new TaskLeg(*tps[position],*tps[position+1])); // 0,1N,N2,2
  
  update_geometry();
}

void
Task::remove(unsigned position)
{
  assert(position>0);
  assert(position<tps.size()-1);

  if (activeTaskPoint>position) {
    activeTaskPoint--;
  }

  delete legs[position-1]; 
  delete legs[position];   // 01,12,23,34 -> 01,34 
  legs.erase(legs.begin()+position-1); // 01,12,23,34 -> 01,23,34 
  legs.erase(legs.begin()+position-1); // 01,12,23,34 -> 01,34 

  delete tps[position];
  tps.erase(tps.begin()+position); // 0,1,2,3 -> 0,1,3

  legs.insert(legs.begin()+position-1,
              new TaskLeg(*tps[position-1],*tps[position])); // 01,13,34

  update_geometry();
}

