/* Generated by Together */

#include "TaskDijkstra.hpp"
#include "Dijkstra.hpp"
#include "Tasks/OrderedTask.h"
#include "Util.h"
#include <algorithm>

unsigned TaskDijkstra::extremal_distance(const unsigned d)
{
  if (shortest) {
    return d;
  } else {
    return -d;
  }
}

TaskDijkstra::~TaskDijkstra() {
}


TaskDijkstra::TaskDijkstra(OrderedTask* _task, const unsigned task_size):
  task(_task),
  shortest(false),
  num_taskpoints(task_size)
{
  solution.reserve(num_taskpoints);
  activeStage = task->getActiveTaskPointIndex();
}


const SearchPoint &
TaskDijkstra::get_point(const ScanTaskPoint &sp) const
{
  return task->get_tp_search_points(sp.first)[sp.second];
}


unsigned TaskDijkstra::distance(const ScanTaskPoint &curNode,
                              const SearchPoint &currentLocation) const
{
  return get_point(curNode).flat_distance(currentLocation);
}

unsigned TaskDijkstra::distance(const ScanTaskPoint &s1,
                              const ScanTaskPoint &s2) const
{
  return get_point(s1).flat_distance(get_point(s2));
}

unsigned 
TaskDijkstra::get_size(unsigned stage) const
{
  return task->get_tp_search_points(stage).size();
}

void TaskDijkstra::add_edges(Dijkstra<ScanTaskPoint> &dijkstra,
                             const ScanTaskPoint& curNode) 
{
  ScanTaskPoint destination;
  destination.first = curNode.first+1;

  const unsigned dsize = get_size(destination.first);

  for (destination.second=0; 
       destination.second< dsize; destination.second++) {

    const unsigned dr = distance(curNode, destination);
    dijkstra.link(destination, curNode, extremal_distance(dr));
  }
}

void TaskDijkstra::add_start_edges(Dijkstra<ScanTaskPoint> &dijkstra,
                                   const SearchPoint &currentLocation) 
{
  ScanTaskPoint destination;
  destination.first = activeStage;

  dijkstra.pop(); // need to remove dummy first point

  const unsigned dsize = get_size(destination.first);

  for (destination.second=0; 
       destination.second< dsize; destination.second++) {

    const unsigned dr = distance(destination, currentLocation);
    dijkstra.link(destination, destination, extremal_distance(dr));
  }
}


unsigned TaskDijkstra::distance_max()
{
  shortest = false;

  const ScanTaskPoint start(0,0);
  Dijkstra<ScanTaskPoint> dijkstra(start);

  unsigned d= distance_general(dijkstra);
  save_max();
  return d;
}

unsigned 
TaskDijkstra::distance_min(const SearchPoint &currentLocation)
{
  shortest = true; 

  const ScanTaskPoint start(std::max(0,(int)activeStage-1),0);
  Dijkstra<ScanTaskPoint> dijkstra(start);
  if (activeStage>0) {
    add_start_edges(dijkstra, currentLocation);
  }
  unsigned d = distance_general(dijkstra);
  save_min();
  return d;
}

unsigned 
TaskDijkstra::distance_general(Dijkstra<ScanTaskPoint> &dijkstra)
{
  unsigned lastStage = -1;
  while (!dijkstra.empty()) {

    const ScanTaskPoint curNode = dijkstra.pop();

    if (curNode.first != lastStage) {
      lastStage = curNode.first;

      if (curNode.first+1 == num_taskpoints) {

        ScanTaskPoint p = curNode;
        ScanTaskPoint pp;
        bool ok = true;
        do {
          pp = p;
          solution[p.first] = get_point(p);
          p = dijkstra.get_predecessor(p);
          ok = (p.first != pp.first) || (p.second != pp.second);
        } while (ok);

        return extremal_distance(dijkstra.dist());
      }
    }
    add_edges(dijkstra, curNode);
  }

  return -1; // No path found
}


void 
TaskDijkstra::save_min()
{
  for (unsigned j=activeStage; j<num_taskpoints; j++) {
    task->set_tp_search_min(j, solution[j]);
  }
}


void 
TaskDijkstra::save_max()
{
  for (unsigned j=0; j<num_taskpoints; j++) {
    task->set_tp_search_max(j, solution[j]);
    if (j<=activeStage) {
      task->set_tp_search_min(j, solution[j]);
    }
  }
}


/*
  TODO/incomplete 

  only scan parts that are required, and prune out points
  that become irrelevant (strictly under-performing) 

  if in sector, prune out all default points that result in
  lower distance than current achieved max

  if searching min 
    first search max actual up to current
      (taking into account aircraft location?)
    then search min after that from aircraft location

  also update saved rank for potential pruning operations

*/
