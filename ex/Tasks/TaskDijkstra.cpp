/* Generated by Together */

#include "Tasks/TaskDijkstra.hpp"
#include "OrderedTask.h"
#include "OrderedTaskPoint.hpp"
#include <stdio.h>

// Example usage (nodes and edges are represented with ints)

#define MAX_DIST 100000

const SearchPoint &
TaskDijkstra::get_point(const ScanTaskPoint &sp) const
{
  return task->tps[sp.first]->get_search_points()[sp.second];
}


unsigned TaskDijkstra::distance(const ScanTaskPoint &curNode,
                              const GEOPOINT &currentLocation)
{
  return ::Distance(get_point(curNode).getLocation(),
                    currentLocation)*10;
}

unsigned TaskDijkstra::distance(const ScanTaskPoint &s1,
                              const ScanTaskPoint &s2)
{
  return get_point(s1).flat_distance(get_point(s2));
}

void TaskDijkstra::add_edges(Dijkstra<ScanTaskPoint> &dijkstra,
                             const ScanTaskPoint& curNode) 
{
  ScanTaskPoint destination;
  destination.first = curNode.first+1;

  unsigned dsize = task->tps[destination.first]->get_search_points().size();

  for (destination.second=0; 
       destination.second< dsize; destination.second++) {

    unsigned dr = distance(curNode, destination);
    if (dr) {
      if (!shortest) {
        dr = MAX_DIST-dr;
      }
      dijkstra.link(destination, dr);
    }
  }
}


TaskDijkstra::~TaskDijkstra() {
}


TaskDijkstra::TaskDijkstra(OrderedTask* _task):
  task(_task),
  shortest(false)
{
  num_taskpoints = task->tps.size();
  solution.reserve(num_taskpoints);
}


unsigned TaskDijkstra::distance_opt(const ScanTaskPoint &start,
                                    const bool req_shortest)
{
  shortest = req_shortest;

  ScanTaskPoint lastNode = start;
  Dijkstra<ScanTaskPoint> dijkstra(start);

  solution[start.first] = get_point(start);

  while (!dijkstra.empty()) {

    ScanTaskPoint curNode = dijkstra.pop();

    if (curNode.first != lastNode.first) {
      solution[curNode.first] = get_point(curNode);
      lastNode = curNode;
    }

    if (curNode.first == num_taskpoints-1) {
      unsigned d = dijkstra.dist();
      if (!shortest) {
        d= MAX_DIST*(curNode.first-start.first)-d;
      }
      return d;
    }

    add_edges(dijkstra, curNode);
  }

  return -1; // No path found
}

unsigned 
TaskDijkstra::distance_opt_achieved(const GEOPOINT &currentLocation,
                                    const bool req_shortest)
{
  shortest = false; // internally

  ScanTaskPoint start(0,0);
  ScanTaskPoint lastNode(1000,1000);
  Dijkstra<ScanTaskPoint> dijkstra(start);

  const unsigned activeStage = task->getActiveTaskPointIndex();

  unsigned min_d = MAX_DIST;
  unsigned min_d_actual = MAX_DIST;
  unsigned max_d_actual = 0;

  while (!dijkstra.empty()) {

    ScanTaskPoint curNode = dijkstra.pop();

    if (curNode.first != lastNode.first) {
      solution[curNode.first] = get_point(curNode);
      lastNode = curNode;
    }

    if (curNode.first != activeStage) {
      add_edges(dijkstra, curNode);
    } else {

      unsigned d_acc = MAX_DIST*activeStage-dijkstra.dist();

      unsigned d_remaining = 0;
      TaskDijkstra inner_dijkstra(task);

      if (curNode.first == num_taskpoints-1) {
        d_remaining = 0;
      } else {
        d_remaining = inner_dijkstra.distance_opt(curNode, req_shortest);
      }

      bool best=false;
      if (req_shortest) {
        // need to take into account distance from here to target

        unsigned d_this = distance(curNode, currentLocation);

        if (d_remaining+d_this<min_d) {
          min_d = d_remaining+d_this; 
          min_d_actual = d_remaining+d_acc;
          best=true;
        }
      } else {
        // here we are only interested in scored distance
        if (d_remaining+d_acc>max_d_actual) {
          max_d_actual = d_remaining+d_acc;
          best=true;
        }
      }
      if (best) {
        solution[curNode.first] = get_point(curNode);

        for (unsigned j=activeStage+1; j<num_taskpoints; j++) {
          solution[j]= inner_dijkstra.solution[j];
        }
      }

    }
  }

  for (unsigned j=0; j<num_taskpoints; j++) {
    if (req_shortest) {
      task->tps[j]->set_search_min(solution[j]);
    } else {
      task->tps[j]->set_search_max(solution[j]);
    }
  }

  if (req_shortest) {
    return min_d_actual; 
  } else {
    return max_d_actual;
  }
}


/*
  TODO/incomplete 

  only scan parts that are required, and prune out points
  that become irrelevant (strictly under-performing) 

  if in sector, prune out all default points that result in
  lower distance than current achieved max

  if searching min 
    first search max actual up to current
      (taking into account aircraft location?)
    then search min after that from aircraft location

  also update saved rank for potential pruning operations

*/
