/* Generated by Together */

#include "AbstractTask.h"
#include "Navigation/Aircraft.hpp"
#include "BaseTask/TaskPoint.hpp"
#include "TaskSolvers/TaskBestMc.hpp"
#include "TaskSolvers/TaskGlideRequired.hpp"
#include "Util.h"
#include <iostream>
#include <fstream>

bool 
AbstractTask::update_idle(const AIRCRAFT_STATE &state)
{
  bool retval = false;
  if (task_behaviour.auto_mc) {
    stats.mc_best = calc_mc_best(state);
    retval = true;
  } else {
    stats.mc_best = glide_polar.get_mc();
  }
  if (task_behaviour.calc_cruise_efficiency) {
    stats.cruise_efficiency = calc_cruise_efficiency(state);
    retval = true;
  } else {
    stats.cruise_efficiency = 1.0;
  }

  return false;
}


unsigned 
AbstractTask::getActiveTaskPointIndex() 
{
  return activeTaskPoint;
}

void
AbstractTask::update_stats_distances(const GEOPOINT &location,
                                     const bool full_update)
{

  stats.total.remaining.set_distance(scan_distance_remaining(location));

  if (full_update) {
    stats.distance_nominal = scan_distance_nominal();
  }

  scan_distance_minmax(location, 
                       full_update,
                       &stats.distance_min,
                       &stats.distance_max);

  stats.total.travelled.set_distance(scan_distance_travelled(location));
  stats.total.planned.set_distance(scan_distance_planned());

  stats.distance_scored = scan_distance_scored(location);

}

void
AbstractTask::update_glide_solutions(const AIRCRAFT_STATE &state)
{
  glide_solution_remaining(state, 
                           stats.total.solution_remaining,
                           stats.current_leg.solution_remaining);

  glide_solution_travelled(state, 
                           stats.total.solution_travelled,
                           stats.current_leg.solution_travelled);

  glide_solution_planned(state, 
                         stats.total.solution_planned,
                         stats.current_leg.solution_planned,
                         stats.total.remaining_effective,
                         stats.current_leg.remaining_effective,
                         stats.total.solution_remaining.TimeElapsed,
                         stats.current_leg.solution_remaining.TimeElapsed);

  stats.current_leg.remaining.set_distance(
    stats.current_leg.solution_remaining.Vector.Distance);
  stats.current_leg.travelled.set_distance(
    stats.current_leg.solution_travelled.Vector.Distance);
  stats.current_leg.planned.set_distance(
    stats.current_leg.solution_planned.Vector.Distance);

  stats.total.gradient = ::AngleToGradient(calc_gradient(state));
  stats.current_leg.gradient = ::AngleToGradient(leg_gradient(state));
}

bool
AbstractTask::update(const AIRCRAFT_STATE &state, 
                     const AIRCRAFT_STATE &state_last)
{
  bool retval;

  glide_polar.set_mc(2.0);

  const bool full_update = check_transitions(state, state_last);

  update_stats_times(state);

  update_stats_distances(state.Location, full_update);

  update_glide_solutions(state);

  retval = update_sample(state, full_update);

  update_stats_glide(state);

  update_stats_speeds(state, state_last);
  return retval;
}

void
AbstractTask::update_stats_speeds(const AIRCRAFT_STATE &state, 
                                  const AIRCRAFT_STATE &state_last)
{
  const double dt = state.Time-state_last.Time;
  stats.total.calc_speeds(dt);
  stats.current_leg.calc_speeds(dt);
}

void
AbstractTask::update_stats_glide(const AIRCRAFT_STATE &state)
{
  stats.glide_required = AngleToGradient(calc_glide_required(state));
}

void
AbstractTask::update_stats_times(const AIRCRAFT_STATE &state)
{
  // default for tasks with no start time...
  stats.total.set_times(scan_total_start_time(state), state);
  stats.current_leg.set_times(scan_leg_start_time(state),state);
}


void 
AbstractTask::scan_distance_minmax(const GEOPOINT &location, bool full,
                                    double *dmin, double *dmax)
{
  *dmin = stats.total.remaining.get_distance();
  *dmax = stats.total.remaining.get_distance();
}

double 
AbstractTask::scan_distance_nominal()
{
  return stats.total.remaining.get_distance();
}

double 
AbstractTask::scan_distance_planned()
{
  return stats.total.remaining.get_distance();
}

double 
AbstractTask::scan_distance_scored(const GEOPOINT &location)
{
  return 0.0;
}

double 
AbstractTask::scan_distance_travelled(const GEOPOINT &location)
{
  return 0.0;
}

double 
AbstractTask::scan_distance_remaining(const GEOPOINT &location)
{
  TaskPoint *tp = getActiveTaskPoint();
  if (!tp) {
    return 0.0;
  }
  return tp->distance(location);
}


void
AbstractTask::glide_solution_remaining(const AIRCRAFT_STATE &state, 
                                       GLIDE_RESULT &total,
                                       GLIDE_RESULT &leg)
{
  GLIDE_RESULT res;

  TaskPoint* tp = getActiveTaskPoint();
  if (tp) {
    res = tp->glide_solution_remaining(state, glide_polar, 0.0);
    res.calc_cruise_bearing();
  }
  total = res;
  leg = res;
}

void 
AbstractTask::glide_solution_travelled(const AIRCRAFT_STATE &state, 
                                       GLIDE_RESULT &total,
                                       GLIDE_RESULT &leg)
{
  GLIDE_RESULT null_res;
  total = null_res;
  leg = null_res;
}

void 
AbstractTask::glide_solution_planned(const AIRCRAFT_STATE &state, 
                                     GLIDE_RESULT &total,
                                     GLIDE_RESULT &leg,
                                     DistanceRemainingStat &total_remaining_effective,
                                     DistanceRemainingStat &leg_remaining_effective,
                                     const double total_t_elapsed,
                                     const double leg_t_elapsed)
{
  GLIDE_RESULT res = stats.total.solution_remaining;
  total = res;
  leg = res;
  total_remaining_effective.set_distance(res.Vector.Distance);
  leg_remaining_effective.set_distance(res.Vector.Distance);
}

void
AbstractTask::report(const AIRCRAFT_STATE &state)
{
  std::ofstream fs("res-stats-all.txt");
  stats.print(fs);

  static std::ofstream f4("res-sample.txt");
  f4 <<  state.Location.Longitude << " " 
     <<  state.Location.Latitude << "\n";
  f4.flush();

  static std::ofstream f6("res-stats.txt");
  static bool first = true;

  if (first) {
    first = false;
    f6 << "# Time atp mc_best d_tot_rem_eff d_tot_rem ceff v_tot_rem v_tot_rem_inc v_tot_eff v_tot_eff_inc\n";
  }
  f6 << state.Time
     << " " << activeTaskPoint
     << " " << stats.mc_best
     << " " << stats.total.remaining_effective.get_distance()
     << " " << stats.total.remaining.get_distance() 
     << " " << stats.cruise_efficiency 
     << " " << stats.total.remaining.get_speed() 
     << " " << stats.total.remaining.get_speed_incremental() 
     << " " << stats.total.remaining_effective.get_speed() 
     << " " << stats.total.remaining_effective.get_speed_incremental() 
     << "\n";
  f6.flush();

}


double 
AbstractTask::scan_total_start_time(const AIRCRAFT_STATE &state)
{
  return state.Time;
}

double 
AbstractTask::scan_leg_start_time(const AIRCRAFT_STATE &state)
{
  return state.Time;
}

double 
AbstractTask::calc_mc_best(const AIRCRAFT_STATE &aircraft)
{
  TaskPoint *tp = getActiveTaskPoint();
  if (!tp) {
    return glide_polar.get_mc();
  }
  TaskBestMc bmc(tp, aircraft, glide_polar);
  return bmc.search(glide_polar.get_mc());
}

double 
AbstractTask::calc_glide_required(const AIRCRAFT_STATE &aircraft)
{
  TaskPoint *tp = getActiveTaskPoint();
  if (!tp) {
    return 0.0;
  }
  TaskGlideRequired bgr(tp, aircraft, glide_polar);
  return bgr.search(0.0);
}


double
AbstractTask::leg_gradient(const AIRCRAFT_STATE &aircraft) 
{
  TaskPoint *tp = getActiveTaskPoint();
  if (!tp) {
    return 0.0;
  }
  const double d = tp->get_vector_remaining(aircraft).Distance;
  if (d) {
    return (aircraft.Altitude-tp->getElevation())/d;
  } else {
    return 0.0;
  }
}

double 
AbstractTask::calc_gradient(const AIRCRAFT_STATE &state) 
{
  return leg_gradient(state);
}
