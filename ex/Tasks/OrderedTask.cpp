/* Generated by Together */

#include "OrderedTask.h"
#include "TaskDijkstra.hpp"
#include "TaskPoints/FAISectorStartPoint.hpp"
#include "TaskPoints/FAISectorFinishPoint.hpp"
#include "TaskPoints/FAISectorASTPoint.hpp"
#include "TaskPoints/FAICylinderASTPoint.hpp"
#include "TaskPoints/CylinderAATPoint.hpp"
#include "TaskSolvers/TaskMacCreadyTravelled.hpp"
#include "TaskSolvers/TaskMacCreadyRemaining.hpp"
#include "TaskSolvers/TaskMacCreadyTotal.hpp"
#include "TaskSolvers/TaskCruiseEfficiency.hpp"
#include "TaskSolvers/TaskBestMc.hpp"
#include "TaskSolvers/TaskMinTarget.hpp"

void
OrderedTask::update_geometry() {

  task_projection.reset(tps[0]->getLocation());
  for (unsigned i=0; i<tps.size(); i++) {
    task_projection.scan_location(tps[i]->getLocation());
  }
//  task_projection.report();

  for (unsigned i=0; i<tps.size(); i++) {
    tps[i]->update_geometry();
    tps[i]->clear_boundary_points();
    tps[i]->default_boundary_points();
    tps[i]->prune_boundary_points();
    tps[i]->update_projection();
  }
}

void 
OrderedTask::scan_distance(const GEOPOINT &location, bool full) 
{ 
  TaskDijkstra dijkstra(this, tps.size());
  ScanTaskPoint start(0,0);

  SearchPoint ac(location, task_projection);

  ts->scan_active(tps[activeTaskPoint]);

  if (full) {
    distance_nominal = ts->scan_distance_nominal();

    // for max calculations, since one can still travel further in the sector,
    // we pretend we are on the previous turnpoint so the search samples will
    // contain the full boundary
    if (activeTaskPoint>0) {
      ts->scan_active(tps[activeTaskPoint-1]);
    }
    distance_max = dijkstra.distance_opt_achieved(ac, false);
    ts->scan_active(tps[activeTaskPoint]);
  }

  distance_min = dijkstra.distance_opt_achieved(ac, true);

  stats.total.remaining.set_distance(ts->scan_distance_remaining(location));
  stats.total.travelled.set_distance(ts->scan_distance_travelled(location));
  distance_scored = ts->scan_distance_scored(location);
  stats.total.planned.set_distance(ts->scan_distance_planned());
}


bool 
OrderedTask::update_sample(const AIRCRAFT_STATE &state, 
                           const AIRCRAFT_STATE& state_last)
{
  ts->scan_active(tps[activeTaskPoint]);

  const int n_task = tps.size();

  if (!n_task) {
    return false;
  }

  stats.total.set_times(ts->get_state_entered().Time, state);

  if (activeTaskPoint>0) {
    stats.current_leg.set_times(tps[activeTaskPoint-1]->get_state_entered().Time,
                                state);
  } else {
    stats.current_leg.set_times(-1,
                                state);
  }

  const int t_min = std::max(0,(int)activeTaskPoint-1);
  const int t_max = std::min(n_task-1, (int)activeTaskPoint+1);
  bool full_update = false;
  
  for (int i=t_min; i<=t_max; i++) {
    if (tps[i]->transition_enter(state, state_last)) {
      printf("  entered %d at %g\n", i, state.Time);
    }
    if (tps[i]->transition_exit(state, state_last)) {
      printf("  exited %d at %g\n", i, state.Time);
      if (i+1<n_task) {
        printf("  -> transition to sector %d\n", i+1);
        setActiveTaskPoint(i+1);
        ts->scan_active(tps[activeTaskPoint]);
        
        // on sector exit, must update samples since start sector
        // exit transition clears samples
        full_update = true;
      }
    }
    if (tps[i]->update_sample(state)) {
      full_update = true;
    }
  }

  double mc = 1.0;
  // must be done in order!
  calc_min_target(state, mc, 3.6);

  scan_distance(state.Location, full_update);

  glide_solution_remaining(state, mc);
  glide_solution_travelled(state, mc);
  glide_solution_planned(state, mc);

  // other calcs

  stats.mc_best = calc_mc_best(state, mc);
  stats.cruise_efficiency = calc_cruise_efficiency(state, mc);

  // do this last
  const double dt = state.Time-state_last.Time;
  stats.total.calc_speeds(dt);
  stats.current_leg.calc_speeds(dt);

  return true;
}

void
OrderedTask::remove(unsigned position)
{
  assert(position>0);
  assert(position<tps.size()-1);

  if (activeTaskPoint>position) {
    activeTaskPoint--;
  }

  delete legs[position-1]; 
  delete legs[position];   // 01,12,23,34 -> 01,34 
  legs.erase(legs.begin()+position-1); // 01,12,23,34 -> 01,23,34 
  legs.erase(legs.begin()+position-1); // 01,12,23,34 -> 01,34 

  delete tps[position];
  tps.erase(tps.begin()+position); // 0,1,2,3 -> 0,1,3

  legs.insert(legs.begin()+position-1,
              new TaskLeg(*tps[position-1],*tps[position])); // 01,13,34

  update_geometry();
}

void 
OrderedTask::insert(OrderedTaskPoint* new_tp, unsigned position)
{
  // remove legs first
  assert(position>0);

  if (activeTaskPoint>=position) {
    activeTaskPoint++;
  }

  delete legs[position-1];
  legs.erase(legs.begin()+position-1); // 0,1,2 -> 0,2

  tps.insert(tps.begin()+position, new_tp); // 0,1,2 -> 0,1,N,2

  legs.insert(legs.begin()+position-1,
              new TaskLeg(*tps[position-1],*tps[position])); // 0,1N,2

  legs.insert(legs.begin()+position,
              new TaskLeg(*tps[position],*tps[position+1])); // 0,1N,N2,2
  
  update_geometry();
}

void OrderedTask::setActiveTaskPoint(unsigned index)
{
  if (index<tps.size()) {
    activeTaskPoint = index;
  }
}

TaskPoint* OrderedTask::getActiveTaskPoint()
{
  if (activeTaskPoint<tps.size()) {
    return tps[activeTaskPoint];
  } else {
    return NULL;
  }
}

OrderedTask::~OrderedTask()
{
// TODO: delete legs and turnpoints
}

OrderedTask::OrderedTask()
{
  // TODO: default values in constructor

  WAYPOINT wp[6];
  wp[0].Location.Longitude=0;
  wp[0].Location.Latitude=0;
  wp[0].Altitude=0.25;
  wp[1].Location.Longitude=0;
  wp[1].Location.Latitude=10;
  wp[1].Altitude=0.25;
  wp[2].Location.Longitude=10;
  wp[2].Location.Latitude=10;
  wp[2].Altitude=0.5;
  wp[3].Location.Longitude=8;
  wp[3].Location.Latitude=5;
  wp[3].Altitude=0.25;
  wp[4].Location.Longitude=10;
  wp[4].Location.Latitude=0;
  wp[4].Altitude=0.25;

  ts = new FAISectorStartPoint(task_projection,wp[0]);
  tps.push_back(ts);
  tps.push_back(new FAISectorASTPoint(task_projection,wp[1]));
  tps.push_back(new CylinderAATPoint(task_projection,wp[2]));
  tps.push_back(new CylinderAATPoint(task_projection,wp[3]));
//  tps.push_back(new FAISectorASTPoint(task_projection,wp[4]));
//  tps.push_back(new FAISectorFinishPoint(task_projection,wp[0]));
  tps.push_back(new FAISectorFinishPoint(task_projection,wp[4]));

  for (unsigned i=0; i+1<tps.size(); i++) {
    legs.push_back(new TaskLeg(*tps[i],*tps[i+1]));
  }

  update_geometry();
}

//////////////////////////////////////

void
OrderedTask::glide_solution_remaining(const AIRCRAFT_STATE &aircraft, 
                                      const double mc)
{
  TaskMacCreadyRemaining tm(tps,activeTaskPoint, mc);
  stats.total.solution_remaining = tm.glide_solution(aircraft);
  stats.current_leg.solution_remaining = tm.get_active_solution();
  stats.current_leg.remaining.set_distance(tm.get_active_solution().Distance);

  std::ofstream fr("res-sol-remaining.txt");
  tm.print(fr, aircraft);
}

void
OrderedTask::glide_solution_travelled(const AIRCRAFT_STATE &aircraft, 
                                      const double mc)
{
  TaskMacCreadyTravelled tm(tps,activeTaskPoint, mc);
  stats.total.solution_travelled = tm.glide_solution(aircraft);
  stats.current_leg.solution_travelled = tm.get_active_solution();
  stats.current_leg.travelled.set_distance(tm.get_active_solution().Distance);
  std::ofstream fr("res-sol-travelled.txt");
  tm.print(fr, aircraft);
}

void
OrderedTask::glide_solution_planned(const AIRCRAFT_STATE &aircraft, 
                                    const double mc)
{
  TaskMacCreadyTotal tm(tps,activeTaskPoint, mc);
  stats.total.solution_planned = tm.glide_solution(aircraft);
  stats.current_leg.solution_planned = tm.get_active_solution();
  stats.current_leg.planned.set_distance(tm.get_active_solution().Distance);
  std::ofstream fr("res-sol-planned.txt");
  tm.print(fr, aircraft);

  stats.total.remaining_effective.
    set_distance(tm.effective_distance(stats.total.solution_remaining.TimeElapsed));

  stats.current_leg.remaining_effective.
    set_distance(tm.effective_leg_distance(stats.current_leg.solution_remaining.TimeElapsed));

}

double
OrderedTask::calc_mc_best(const AIRCRAFT_STATE &aircraft, 
                          const double mc)
{
  TaskBestMc bmc(tps,activeTaskPoint, aircraft);
  return bmc.search(mc);
}


double
OrderedTask::calc_cruise_efficiency(const AIRCRAFT_STATE &aircraft, 
                                    const double mc)
{
  TaskCruiseEfficiency bce(tps,activeTaskPoint, aircraft, mc);
  return bce.search(mc);
}

double
OrderedTask::calc_min_target(const AIRCRAFT_STATE &aircraft, 
                             const double mc,
                             const double t_target)
{
  // TODO: look at max/min dist and only perform this scan if
  // change is possible
  const double t_rem = std::max(0.0, t_target-stats.total.TimeElapsed);

  TaskMinTarget bmt(tps, activeTaskPoint, aircraft, t_rem, ts);
  double p= bmt.search(mc);
  printf("target opt %g\n",p);
  return p;
}


////////////////////////// Reporting/printing for debugging


extern int count_distance;
extern long count_mc;

void OrderedTask::report(const AIRCRAFT_STATE &state) 
{
  static bool first = true;
  std::ofstream f1("res-task.txt");
  std::ofstream f2("res-max.txt");
  std::ofstream f3("res-min.txt");
  static std::ofstream f4("res-sample.txt");
  std::ofstream f5("res-ssample.txt");
  static std::ofstream f6("res-stats.txt");

  if (first) {
    first = false;
    f6 << "# Time atp mc_best dist_rem_eff dist_rem cruis_eff sir sire\n";
  }
  f6 << state.Time
     << " " << activeTaskPoint
     << " " << stats.mc_best
     << " " << stats.total.remaining_effective.get_distance()
     << " " << stats.total.remaining.get_distance() 
     << " " << stats.cruise_efficiency 
     << " " << stats.total.remaining.get_speed() 
     << " " << stats.total.remaining.get_speed_incremental() 
     << " " << stats.total.remaining_effective.get_speed() 
     << " " << stats.total.remaining_effective.get_speed_incremental() 
     << "\n";
  f6.flush();

  f1 << "#### Distances\n";
  f1 << "# dist nominal " << distance_nominal << "\n";
  f1 << "# min dist after achieving max " << distance_min << "\n";
  f1 << "# max dist after achieving max " << distance_max << "\n";
  f1 << "# dist scored " << distance_scored << "\n";

  stats.print(f1);

  f1 << "#### Task points\n";
  for (unsigned i=0; i<tps.size(); i++) {
    f1 << "## point " << i << "\n";
    tps[i]->print(f1);
  }

  f5 << "#### Task sampled points\n";
  for (unsigned i=0; i<tps.size(); i++) {
    f5 << "## point " << i << "\n";
    tps[i]->print_samples(f5);
  }

  f4 <<  state.Location.Longitude << " " 
     <<  state.Location.Latitude << "\n";
  f4.flush();

  f2 << "#### Max task\n";
  for (unsigned i=0; i<tps.size(); i++) {
    OrderedTaskPoint *tp = tps[i];
    f2 <<  tp->getMaxLocation().Longitude << " " 
       <<  tp->getMaxLocation().Latitude << "\n";
  }

  f3 << "#### Min task\n";
  for (unsigned i=0; i<tps.size(); i++) {
    OrderedTaskPoint *tp = tps[i];
    f3 <<  tp->getMinLocation().Longitude << " " 
       <<  tp->getMinLocation().Latitude << "\n";
  }
}
