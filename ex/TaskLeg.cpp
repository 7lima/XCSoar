/* Generated by Together */

#include "TaskLeg.h"
#include "Util.h"
#include "OrderedTaskPoint.hpp"
#include <assert.h>

//////



////////


double TaskLeg::leg_distance_scored(const GEOPOINT &ref)
{
  switch (tp_destination->getActiveState()) {
  case OrderedTaskPoint::BEFORE_ACTIVE:
    // todo refine
    // this leg totally included
    return ::Distance(tp_origin->getLocation(), 
                      tp_destination->getLocation());
    break;
  case OrderedTaskPoint::AFTER_ACTIVE:
    // this leg not included
    return 0.0;
  case OrderedTaskPoint::CURRENT_ACTIVE:
    // todo refine
    // this leg partially included
    return ::ProjectedDistance(tp_origin->getLocation(), 
                               tp_destination->getLocation(),
                               ref);
    break;
  default:
    assert(1); // error!
    break;
  };
}


double TaskLeg::leg_distance_remaining(const GEOPOINT &ref)
{
  switch (tp_destination->getActiveState()) {
  case OrderedTaskPoint::AFTER_ACTIVE:
    // todo refine
    // this leg totally included
    return ::Distance(tp_origin->getLocation(), 
                      tp_destination->getLocation());
    break;
  case OrderedTaskPoint::BEFORE_ACTIVE:
    // this leg not included
    return 0.0;
  case OrderedTaskPoint::CURRENT_ACTIVE:
    // todo refine
    // this leg partially included
    return ::Distance(ref, 
                      tp_destination->getLocation());
    break;
  default:
    assert(1); // error!
    break;
  };
}

double TaskLeg::leg_distance_travelled(const GEOPOINT &ref)
{
  switch (tp_destination->getActiveState()) {
  case OrderedTaskPoint::BEFORE_ACTIVE:
    // todo refine
    // this leg totally included
    return ::Distance(tp_origin->getLocation(), 
                      tp_destination->getLocation());
    break;
  case OrderedTaskPoint::AFTER_ACTIVE:
    // this leg not included
    return 0.0;
  case OrderedTaskPoint::CURRENT_ACTIVE:
    // todo refine
    // this leg partially included
    return ::Distance(tp_origin->getLocation(), 
                      ref);
    break;
  default:
    assert(1); // error!
    break;
  };
}

double TaskLeg::leg_distance_nominal()
{
  return ::Distance(tp_origin->getLocation(), 
                    tp_destination->getLocation());
}


///////

void TaskLeg::update_geometry()
{
  tp_origin->update_geometry();
  tp_destination->update_geometry();
}


TaskLeg::TaskLeg(OrderedTaskPoint& origin,
                 OrderedTaskPoint& destination):
  tp_origin(&origin),
  tp_destination(&destination)
{
  tp_origin->set_leg_out(this);
  tp_destination->set_leg_in(this);
}


OrderedTaskPoint* TaskLeg::get_destination() const {
  return tp_destination;
}

OrderedTaskPoint* TaskLeg::get_origin() const {
  return tp_origin;
}

