<?xml version="1.0" encoding="UTF-8"?>
<document>
        <metadata>
                <title>Input and Events</title>
        </metadata>

        <content>

		<h1>Input and Events</h1>

<h2>Introduction</h2>

<p>
The Input System is actually a large number of things all bunched into one.
</p>

<p>
Primarily it is about giving the user control of what button does what
and when. There is a new concept called Input Mode - this is a the mode
the GUI is in for input. For example, you can click on the info boxes
and you are now in "infobox" mode. Clicking on the map is called
"default". But it doesn't stop there, you can create a new mode called
anything you like. This may not mean much - but wait till you combine it
with the rest of the features...
</p>

<p>
Input is not restricted to hardware buttons any more. You can map all
your hardware buttons (currently support for APP1 to APP6, Left, Right,
Up, Down and Enter, although I believe we can do some more) but also any
key code at all. This feature allows those with a built in keyboard to
use any key to map to any function in XCS. Where it comes into real
advantage is in external keyboards. There are a number of bluetooth
devices out there (eg: http://shop.brando.com.hk/btgamepad.php) which
can map each of their buttons to any key code - that key code can then
be mapped to any feature in XCS. You can then add to the hardware
buttons the buttons available to you on external devices. Other inputs
(eg: Serial) are also being looked at - and support is in the code for
that extension.

We are striving towards a platform which is not only easier to use and
more intuitive, but also faster and easier to use in flight as well. As
such, another new feature as part of input is the concept of Button
Labels. Combined with the modes mentioned above, you can create any
arbitrary set of functions to map to any number of buttons. Think about
it like creating a tree, or a multiple level menu.
</p>

<p>
This produces two benefits that I know will be appreciated by people
with limited inputs. The first is that you can create menus, where by
you press one button to get to the next level (eg: pressing on APP1
brings up AutoZoom, Pan Mode, Full screen on the other buttons. Press
APP1 again and it goes to Terrain, Marker and Auto McCready. Press APP1
again and the menu is gone) - but more importantly for those with touch
screens and limited buttons, each of these labels can optionally be
assigned a key and you can touch the button area as if it was a button.
This means that we can actually control on a touch screen model the
entire system without buttons - press an area of the screen and the
buttons pop up, click through - change options and more.

</p>

<p>
The combined features of labels, configurable buttons (including from
external hardware), hierarchical menus (for lack of a better name),
touch screen buttons has allowed us to configure XCS - without
recompile - for an enormous range of hardware, and personal preference.
And all configurable as plane text, simple files. There is no need for
a file, the defaults internally will probably be a combination of a 4
button bottom system with one button always shown on screen for no/few
button display.
</p>

<p>
The screen layout - location of the labels - is also totally
configurable - allowing us to vary the layout of buttons depending on
the type of organiser or desired look and feel.
</p>

<p>
There is a great unexpected benefit in the development of the
input system.
</p>

<p>
We can execute any number of events attached to an input with only 2
extra lines of code. This worked perfectly. So now we have a basic
macro system, allowing many more events to be attached to a single
input event.
</p>

<p>
But it doesn't stop there, this has lead to some more excellent
developments. The idea of Glide Computer Events things like
"Maximum Height Reached". Currently we play a sound effect for
that. But you may choose to play a sound, bring up a message box
and write to the log file.
</p>

<p>
One nice feature of XCS is the ability to change things such as Zoom and
North when Circling. Now you can do so much more. You could choose to
point North, Zoom to 1.0 (rather than a relative change), Turn on Vario
Sounds, Start a timer. When switching back to Cruise mode, you can bring
up the stats box for 30 seconds. The options are limited by your
imagination.
</p>

<p>
This is also contributing to a major reduction in complex code. We can
move out these complex tests into one centrally, easier to manage
system, reducing bugs and improving maintainability.
</p>

<p>
Another side benefits of these Macros is User Defined Flight Modes. One
idea was a button which switched to Zoom 1.0, Pan ON, Pan Move to Next
Waypoint. Basically the ability to jump and see the next waypoint. And
in the previous we can change the Input Mode to "ViewWaypoint" - at
which point you can redefine the same button to switch back to your
original settings.
</p>

<p>
The flexibility of this system comes with only one small price. We can't
provide an interface within XCS to fully customise all of these near
infinitely variable possibilities. However I believe that is unnecessary
anyway, you are not likely to change these sort of features very often,
and definitely not on the field. That does not mean you can't, you can
of course edit the plane(sic) text file to change functions.
</p>

<p>
What this really means is that we can have people in the project helping
and contributing to the customising of XCS, without having to change the
code. This, especially on an open source project is fantastic as it
nicely separates the user interface changes from the highly reliable
part of the code. It also involves people who can develop new interfaces
and functions that are expert gliders but not necessarily programmers.
</p>

<p>
For information on file formats see Common/Data/Input/template.xci and
the web site documentation.
</p>


<h2>Defaults and Files</h2>

<p>The file in the source Common/Data/input/template.xci is used to generate
automatically the C code necessary for the default configuration. However it is
in the exact same format as can be read in by XCS and therefore can be used
literally as a template for a more complicated file.
</p>

<p>When you create your own file, you will need to select it as the Input File
within XCSoar Menu/Settings/Input Files, and then restart XCS.</p>

<h2>File Format</h2>

<p>The file is plain text, with key=value pairs and a blank line to indicate
the end of a record.</p>

<pre>
mode=default
type=key
data=APP1
event=StatusMessage My favorite settings are done
event=ScreenModes full
event=Sounds on
event=Zoom 1.0
event=Pan off
label=My Prefs
location=1
</pre>

<p>The record above demonstrates remapping the first hardware key on your
organiser to change Pan to off, Zoom to 1.0 Sounds on, ScreenModes full, and
then a status message to tell you it is done.
</p>

<p>
Lines are terminated by the stanard DOS newline which is CRLF (Carrage Return
then Line Feed). Records are terminated by an extra new line.
</p>

<h2>Event order</h2>

<p>Until further work is done on processing, events are actually done in
reverse order - also known as RPN. This is because the events work on the stack
principle. Each one is pushed onto the stack for execution, and then executed
by popping back off the stack. This has reduced complexity of the code base.
</p>

<p>When writing input events, have a look where you put the StatusMessage and
make sure that it is at the top, not the bottom (if you have one).</p>

<h2>Event List</h2>

<ul>
	<li><a href="/ref/events/ScreenModes/">ScreenModes</a></li>
	<li><a href="/ref/events/SnailTrail/">SnailTrail</a></li>
	<li><a href="/ref/events/Sounds/">Sounds</a></li>
	<li><a href="/ref/events/MarkLocation/">MarkLocation</a></li>
	<li><a href="/ref/events/Zoom/">Zoom</a></li>
	<li><a href="/ref/events/Pan/">Pan</a></li>
	<li><a href="/ref/events/ClearWarningsAndTerrain/">ClearWarningsAndTerrain</a></li>
	<li><a href="/ref/events/SelectInfoBox/">SelectInfoBox</a></li>
	<li><a href="/ref/events/ChangeInfoBoxType/">ChangeInfoBoxType</a></li>
	<li><a href="/ref/events/DoInfoKey/">DoInfoKey</a></li>
	<li><a href="/ref/events/MainMenu/">MainMenu</a></li>
	<li><a href="/ref/events/Mode/">Mode</a></li>
	<li><a href="/ref/events/Status/">Status</a></li>
	<li><a href="/ref/events/Analysis/">Analysis</a></li>
	<li><a href="/ref/events/WaypointDetails/">WaypointDetails</a></li>
	<li><a href="/ref/events/StatusMessage/">StatusMessage</a></li>
	<li><a href="/ref/events/PlaySound/">PlaySound</a></li>
	<li><a href="/ref/events/AdjustMcCready/">AdjustMcCready</a></li>
	<li><a href="/ref/events/AdjustWind/">AdjustWind</a></li>
	<li><a href="/ref/events/AdjustVarioFilter/">AdjustVarioFilter</a></li>
	<li><a href="/ref/events/AdjustWaypoint/">AdjustWaypoint</a></li>
	<li><a href="/ref/events/AbortTask/">AbortTask</a></li>

</ul>


<h2>Modes</h2>

<p>
XCSoar now has the concept of Modes. These are an arbitrary
string that associates with where and what XCS is doing.
</p>

<p>Note: a mode entry in a record can have multiple entries by using a space
between eg: "infobox menu1 menu2"
</p>

<p>List of known modes</p>
<ul>
	<li>default - Really map mode, where you mostly are</li>
	<li>infobox - An info box has been selected on the scrreen</li>
	<li>* - Any other arbitrary string</li>
</ul>

<p>
Mode precedence has been tricky, so instead of solving the problem 
it is being worked around. XCS will choose to set a global variable 
to specify what mode it thinks it is in. This can then be used by the
input code to decide what to do. This mode could get out of sink
with the real world, and careful checking will be required, but at
this stage it seems like the only sensible option.
</p>

<p>
The code will review first if an entry exists in the current mode, and 
then in the default mode. This allows you to do one of the following
example: Define a default action for button "A" to be "Zoom In" but
make that button increase Bugs value in infobox mode only. You can do
this by making an "default" and a "infobox" entry. You can also put an entry
in for Button "A" for every mode and have complete control.
</p>

<p>
Special Modes - eg: the level of a menu (Think File vs Edit, vs Tools vs Help)
</p>

<p>
have special modes, such as
the level of the menu you are at. You press one button, then another
set become available (like pressing menu and seeing Settings etc). This
will be very useful in non-touch screen models. The menu configuration
can then be read from this same file and configured, allowing any
number of levels and any number of combinations.
</p>

<p>
The only hard part is what mode to go back to. We need a 
"Calculate Live Mode" function - which can be called to calculate the
real live mode (eg: finalglide vs curse) rather than the temporary
mode such as Menu, Special Menu Level, Warning etc.
</p>

<p>
The label and location values are examples of what can be done here
to allow input button labels to be displayed. What needs to be 
considered is a simple way of mapping the locations and the size.
In some models it may be that buttons are 4 across the top of the
screen, where as others it is 3 or 2 or even 6. So both size and
location needs to be considered.
</p>

<p>
The label itself will go through gettext to allow language
translations.
</p>


<h2>Keys</h2>

<p>The key type can have the following possible values</p>

<ul>
	<li>APP1 - APP6 - Hardware key on pocket pc</li>
	<li>F1-F12 - Standard function keys</li>
	<li>LEFT, RIGHT, UP, DOWN, RETURN - Mapped to arrow keys - joystick on
organisers</li>
	<li>A-Z, 0-9 - and other possible keyboard buttons (case is ignored)</li>
</ul>

Input Types

Types:

hardware	These are the standard hardware buttons 
on normal organisers. Usually these are
APP1..6.

keyboard	Normal characters on the keyboard (a-z etc)

nmea		A sentence received via NMEA stream (either)

virtual		Virtual buttons are a new idea, allowing
multiple buttons to be created on screen.
These buttons can then be optionally mapped
to physical buttons or to a spot on the 
screen (probably transparent buttons over 
the map).

Modifiers

It is a long term goal of this project to allow modifiers for keys.
This could include one of the following possibilities:

* Combination presses (although not supported on many devices)

* Double Click

* Long Click

Modifiers such as the above will not be supported in the first release.

Functions/Events - what it does

AutoZoom		on, off, toggle 
FullScreen		on, off, toggle
SnailTrail 		on, off, long, toggle
VarioSound 		on, off
Marker 			optional text to add
MenuButton 		on, off, toggle
Menu			open, close, toggle
MenuEntry		task, b+b, abortresume, abore, resume, pressure
logger, settings, status, analysis, exit, cancel
NOTE: Some of the above may be separate functions
Settings		(each setting, bring up to that point)
Bugs			add, subtract, 0-100% (set value)
Ballast			add, subtract, 0-100% (set value)
Zoom			add, subtract, 0-nn (set value)
Wind			up, down, 0-nn (set value, left, right, "n","ne","e","se","s","sw","w","nw"...
McCready		add, subtract, 0-nn (set value)
WaypointNext		"String" to specific waypoint
eg: WayPointNext "home"
WayPoint???		"reverse" - reverse, from last passed back to start (ie: from here to home)
"drop next" - drop the next
"restore" - restore all - from start of flight but 
XXX This needs more thought
flight 			"startstop", "start", "stop", "release"
Start/Stop of flight - Can be automatic, but pressing will override
automatic part.
release 		markse the point of release from tow


<h2>Glide Computer Events</h2>

<p>These are automatically triggered events. They work in exactly the same way,
but instead of the user pressing a key, the glide computer triggers the events.
</p>

<p>A simple example is moving from Cruise to Climb mode. We want to zoom in,
change our track up to north up and switch to full screen. You may also choose
to drop a marker with the words "entered thermal". The choicese are up to your
imaginations - the GCE (Glide Computer Events) allow you to control what
happens.</p>

<p>These are represented as "type=gce" and data=* - as lited below.</p>

<ul>
	<li><a href="/ref/gce/FLIGHTMODE_FINALGLIDE/">FLIGHTMODE_FINALGLIDE</a></li>
	<li><a href="FLIGHTMODE_CRUISE">FLIGHTMODE_CRUISE</a></li>
	<li><a href="FLIGHTMODE_CLIMB">FLIGHTMODE_CLIMB</a></li>
	<li><a href="HEIGHT_MAX">HEIGHT_MAX</a></li>
	<li><a href="GPS_CONNECTION_WAIT">GPS_CONNECTION_WAIT</a></li>
	<li><a href="COMMPORT_RESTART">COMMPORT_RESTART</a></li>
	<li><a href="GPS_FIX_WAIT">GPS_FIX_WAIT</a></li>
	<li><a href="STARTUP_SIMULATOR">STARTUP_SIMULATOR</a></li>
	<li><a href="STARTUP_REAL">STARTUP_REAL</a></li>
	<li><a href="TAKEOFF">TAKEOFF</a></li>
	<li><a href="LANDING">LANDING</a></li>
</ul>

</content>
</document>
